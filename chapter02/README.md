# 1. Functions and Variables

## 1. Hello World!

```kotlin
fun helloWorld() {
    println("Hello World!")
}
```

kotlin에서는 다음과 같은 규칙을 바탕으로 프로그래밍을 합니다.

1. 함수를 선언할 때는 `fun` 키워드를 사용합니다.
2. 파라미터 이름 뒤에 파라미터의 타입을 씁니다.
3. 함수를 최상위 수준에서 정의할 수 있습니다. 자바와 달리 클래스 안에 함수를 넣을 필요가 없습니다.
4. 배열도 일반적인 클래스로 처리합니다. 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않습니다.
5. `System.out.println` 대신에 `println`을 사용해 출력합니다. kotlin은 자바 라이브러리 함수를 간결하게 사용하는 wrapper를 제공합니다.
6. 라인의 끝에 `;`을 붙이지 않아도 됩니다.

## 2. Function

```kotlin
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

kotlin의 함수는 `fun` 키워드 다음에 함수 이름이 옵니다. 그리고 소괄호 안에 파라미터 목록이 적힙니다. 그 뒤에는 `:`을 붙이고 함수의 반환값의 타입을 적어줍니다. 그 결과는 위의 예시와 같습니다.

```plain text
statement와 expression의 구분

kotlin에서 if는 식(expression)이지 문(statement)이 아닙니다. 식은 값을 만들고 다른 식의 하위 요소로 계산에 참여할 수 있지만 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않습니다.

자바에서느 모든 제어 구조가 문인 반면 kotlin에서는 loop를 제외한 대부분의 제어 구조가 식입니다. 따라서 제어 구조를 다른 식으로 엮어낼 수 있으면 여러 일반적인 패턴을 아주 간결하게 표현할 수 있습니다.

반면 대입문은 자바에서는 식이었으나 kotlin에서는 문이 되었습니다. 그로 인해 자바와 달리 대입식과 비교식을 잘못 바꿔 써서 버그가 생기는 경우가 없습니다.
```

예시 함수를 더 간결하게 줄일 수 있습니다. 함수 본문이 식 하나로 이루어진 경우가 이에 해당합니다.

```kotlin
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

만약 이를 더 간결하게 줄인다면 함수의 반환 타입을 없앨 수 있습니다.

```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

이는 kotlin이 정적 타입 언어이지만 kotlin compiler가 함수 본문 식을 분석해 그 결과 타입을 함수 반환 타입으로 정해줍니다. 이를 **타입 추론**이라고 합니다. 다만 위와 같이 생략하기 위해서는 식이 본문인 함수의 반환 타입만 생략 가능함을 인지해야 합니다.

## 3. Variable

자바에서 변수를 선언할 때 타입이 맨 앞에 오지만 kotlin은 타입 지정을 생략하는 경우가 흔합니다. 이는 타입으로 변수 선언을 시작하면 타입을 생략한 경우 식과 변수 선언을 구별할 수 없기 때문입니다. 따라서 kotlin은 키워드로 변수 선언을 시작하는 대신에 이름 뒤에 타입을 명시하거나 생략해 사용합니다.

```kotlin
val answer = 42
val answer: Int = 42
```

만일 타입이 지정되지 않았다면 컴파일러가 식을 분석해서 변수 타입을 지정합니다. 만약 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 합니다.

```kotlin
val answer: Int

answer = 42
```

kotlin도 변경 가능한 변수와 변경 불가능한 변수가 있습니다.

1. `val`: 변경 불가능한 참조를 저장하는 변수입니다. 선언된 변수는 재대입이 불가능합니다. 자바에서는 `final`에 대응합니다.
2. `var`: 변경 가능한 참조입니다. 이 변수의 값은 언제든지 바뀔 수 있으며 자바의 일반 변수에 해당합니다.

일반적으로 모든 변수를 `val`로 선언하고 필요한 경우에만 `var`을 사용하는 것을 추천합니다. `val`은 블록을 실행할 때 정확히 한 번만 초기화돼야 합니다. 하지만 어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 알 수 있다면 조건에 따라 `val`을 여러 값으로 초기화할 수 있습니다.

```kotlin
fun variables(isTrue: Boolean): String {
    val message: String

    if (isTrue == true) {
        message = "Success"
    } else {
        message = "Failed"
    }

    return message
}
```

단, `val` 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있습니다. 반면에 `var` 키워드는 변수의 값을 변경할 수 있지만 변수 타입은 고정되어 바꿀 수 없습니다.

```kotlin
val languages = arrayListOf("Java")
languages.add("Kotlin")

var answer = 42
answer = "no" // Error: type mismatch
```

만약 어떤 타입의 변수에 다른 타입의 값을 저장하고 싶다면 변환 함수를 써서 값을 변수의 타입으로 변환하거나 값을 변수에 대입할 수 있는 타입으로 강제 형 변환해야 합니다.

## 4. String template

```kotlin
fun greeting(args: Array<String>) {
    val name = if (args.size > 0) args[0] else "Kotlin"
    println("Hello $name!")
}
```

위 예제는 **문자열 템플릿** 기능에 대한 예제입니다. kotlin에서 변수를 문자열 안에서 사용하기 위해서 문자열에 변수를 넣되 변수 앞에 `$`를 추가해야 합니다. 이는 자바의 문자열 접합 연산과 동일한 기능이지만 좀 더 간결하며 자바 문자열 접합 연산을 사용한 식과 마찬가지로 효율적입니다. 물론 컴파일러가 각 식을 정적으로 검사하기 때문에 존재하지 않는 변수를 문자열 템플릿 안에서 사용하면 오류가 발생합니다.

만약 복잡한 식을 사용해야 한다면 `{}`를 사용해서 문자열 템플릿 안에 넣을 수 있습니다.

```plain text
한글을 문자열 템플릿에서 사용할 경우 주의할 점

kotlin은 자바와 마찬가지로 한글을 식별자에 사용할 수 있어 변수 이름에 한글이 들어갈 수 있습니다. 하지만 문자열 템플릿을 사용할 때 $ 뒤에 변수를 입력하고 바로 문자를 사용하면 이들을 하나로 인식해 컴파일러 오류가 발생합니다. 이 때 ${variables}와 같이 변수를 {}로 감싸면 오류를 해결할 수 있습니다.
```

또한 {}로 둘러싼 식에서 ""를 사용할 수 있습니다.

```kotlin
fun call(args: Array<String>) {
    println("Hello ${if (args.size > 0) args[0] else "someone"}!")
}
```
